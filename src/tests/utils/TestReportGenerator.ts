import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { TestResultAnalyzer } from './TestResultAnalyzer';

interface ReportConfig {
  outputDir: string;
  projectName: string;
  version: string;
  environment: {
    os: string;
    node: string;
    browser?: string;
  };
  includeScreenshots?: boolean;
  includeLogs?: boolean;
  includePerformanceData?: boolean;
  includeCodeCoverage?: boolean;
}

export class TestReportGenerator {
  private analyzer: TestResultAnalyzer;
  private config: ReportConfig;
  private reportDate: Date;
  private coverageData?: any;
  private screenshots: string[] = [];
  private logs: string[] = [];
  private performanceData?: any;

  constructor(analyzer: TestResultAnalyzer, config: ReportConfig) {
    this.analyzer = analyzer;
    this.config = config;
    this.reportDate = new Date();

    // 确保输出目录存在
    if (!existsSync(config.outputDir)) {
      mkdirSync(config.outputDir, { recursive: true });
    }
  }

  setCoverageData(data: any) {
    this.coverageData = data;
  }

  addScreenshot(path: string) {
    this.screenshots.push(path);
  }

  addLog(log: string) {
    this.logs.push(log);
  }

  setPerformanceData(data: any) {
    this.performanceData = data;
  }

  generateReport() {
    const report = this.generateReportContent();
    this.writeReport(report);
    this.generateAssets();
  }

  private generateReportContent(): string {
    let content = this.generateHeader();
    content += this.generateEnvironmentInfo();
    content += this.analyzer.generateReport();
    
    if (this.config.includeCodeCoverage && this.coverageData) {
      content += this.generateCoverageReport();
    }

    if (this.config.includePerformanceData && this.performanceData) {
      content += this.generatePerformanceReport();
    }

    if (this.config.includeScreenshots && this.screenshots.length > 0) {
      content += this.generateScreenshotSection();
    }

    if (this.config.includeLogs && this.logs.length > 0) {
      content += this.generateLogSection();
    }

    content += this.generateFooter();
    return content;
  }

  private generateHeader(): string {
    return `# Test Report: ${this.config.projectName} v${this.config.version}

Generated on: ${this.reportDate.toLocaleString()}

`;
  }

  private generateEnvironmentInfo(): string {
    return `## Environment

- Operating System: ${this.config.environment.os}
- Node.js Version: ${this.config.environment.node}
${this.config.environment.browser ? `- Browser: ${this.config.environment.browser}` : ''}

`;
  }

  private generateCoverageReport(): string {
    let content = `## Code Coverage

`;

    if (this.coverageData.summary) {
      content += `### Summary

- Statements: ${this.coverageData.summary.statements}%
- Branches: ${this.coverageData.summary.branches}%
- Functions: ${this.coverageData.summary.functions}%
- Lines: ${this.coverageData.summary.lines}%

`;
    }

    if (this.coverageData.files) {
      content += `### File Coverage

| File | Statements | Branches | Functions | Lines |
|------|------------|----------|-----------|-------|
`;

      this.coverageData.files.forEach((file: any) => {
        content += `| ${file.name} | ${file.statements}% | ${file.branches}% | ${file.functions}% | ${file.lines}% |\n`;
      });

      content += '\n';
    }

    return content;
  }

  private generatePerformanceReport(): string {
    let content = `## Performance Metrics

`;

    if (this.performanceData.timings) {
      content += `### Execution Times

| Test | Average Time | Min Time | Max Time |
|------|--------------|----------|----------|
`;

      this.performanceData.timings.forEach((timing: any) => {
        content += `| ${timing.name} | ${timing.average}ms | ${timing.min}ms | ${timing.max}ms |\n`;
      });

      content += '\n';
    }

    if (this.performanceData.memory) {
      content += `### Memory Usage

- Initial: ${this.formatBytes(this.performanceData.memory.initial)}
- Peak: ${this.formatBytes(this.performanceData.memory.peak)}
- Final: ${this.formatBytes(this.performanceData.memory.final)}

`;
    }

    return content;
  }

  private generateScreenshotSection(): string {
    let content = `## Screenshots

`;

    this.screenshots.forEach((screenshot, index) => {
      content += `### Screenshot ${index + 1}

![Screenshot ${index + 1}](${screenshot})

`;
    });

    return content;
  }

  private generateLogSection(): string {
    return `## Test Logs

\`\`\`
${this.logs.join('\n')}
\`\`\`

`;
  }

  private generateFooter(): string {
    return `
---
Report generated by Test Report Generator
`;
  }

  private writeReport(content: string) {
    const filename = `test-report-${this.reportDate.toISOString().split('T')[0]}.md`;
    const filepath = join(this.config.outputDir, filename);
    writeFileSync(filepath, content);

    // 生成HTML版本
    const html = this.convertMarkdownToHtml(content);
    const htmlFilepath = join(this.config.outputDir, filename.replace('.md', '.html'));
    writeFileSync(htmlFilepath, html);
  }

  private generateAssets() {
    // 复制截图到资源目录
    if (this.config.includeScreenshots && this.screenshots.length > 0) {
      const assetsDir = join(this.config.outputDir, 'assets');
      if (!existsSync(assetsDir)) {
        mkdirSync(assetsDir);
      }

      this.screenshots.forEach((screenshot, index) => {
        // 复制截图文件到资源目录
        // 这里需要实际的文件复制逻辑
      });
    }
  }

  private convertMarkdownToHtml(markdown: string): string {
    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Test Report: ${this.config.projectName}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      color: #333;
    }
    h1, h2, h3 { color: #2c3e50; }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th { background-color: #f8f9fa; }
    code {
      background-color: #f8f9fa;
      padding: 2px 4px;
      border-radius: 4px;
    }
    pre {
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 4px;
      overflow-x: auto;
    }
    img {
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin: 1rem 0;
    }
    .success { color: #28a745; }
    .warning { color: #ffc107; }
    .error { color: #dc3545; }
  </style>
</head>
<body>
  ${this.convertMarkdownToHtmlContent(markdown)}
</body>
</html>`;
  }

  private convertMarkdownToHtmlContent(markdown: string): string {
    // 这里应该使用一个Markdown解析器来转换内容
    // 为了简单起见，这里只做基本的转换
    return markdown
      .replace(/^# (.*$)/gm, '<h1>$1</h1>')
      .replace(/^## (.*$)/gm, '<h2>$1</h2>')
      .replace(/^### (.*$)/gm, '<h3>$1</h3>')
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/\n/g, '<br>');
  }

  private formatBytes(bytes: number): string {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }

    return `${size.toFixed(2)} ${units[unitIndex]}`;
  }
} 